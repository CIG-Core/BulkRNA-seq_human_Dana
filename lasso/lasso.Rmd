---
title: "Biswas_Ascherman_DEseq2_Remove_Outliers_Filter_Counts"
author: 
- name: "Computational Immunogenomics Core (CIG Core)"
  affiliation: "Center for Systems Immunology, University of Pittsburgh"
  email: "sis186@pitt.edu"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true # table of content true
    toc_depth: 3  # upto three depths of headings (specified by #, ## and ###)
    toc_float:
      collapsed: true
      smooth_scroll: true
    number_sections: true  ## if you want number sections at each table header
    theme: "default" # many options for theme, this one is my favorite.
    highlight: tango  # specifies the syntax highlighting style
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

## Libraries
suppressMessages({
  library(openxlsx)
  library(biomaRt)
  library(stringr)
  library(matrixStats)
  library(pheatmap)
  library(dplyr)
  library(ggfortify)
  library(org.Hs.eg.db)
  library(WebGestaltR)
  library(DESeq2)
  library(apeglm)
  library(EnhancedVolcano)
  library(ReactomeContentService4R)
  library('janitor') #use the function: row_to_names
})

library("RNAseqQC")
library("ensembldb")
library("dplyr")
library("ggplot2")
library("purrr")
library("tidyr")
library("tibble")
library("magrittr")
library(DEGreport)
library(writexl)
library("glmnet")
library("caret")  # For cv.glmnet function
## Sourcing
source("/ix/cigcore/utils/code/de.heatmap.R")


library(sleuth)
library(VennDiagram)
library(AnnotationDbi)
library(enrichplot)
library(tidyverse)
library(cowplot) #plot_grid

## Set paths
proj_path <- "/ix/cigcore/proj/biswas"
data_path <- file.path(proj_path, "data", "Ascherman_TotalRNA_07_20_2023")
resPath <- gsub(pattern="data", replacement="result", data_path)
experiment <- "2-19-2023-DE_analysis_deseq2_lasso"
experimentPath <- file.path(resPath, experiment)
dir.create(experimentPath, showWarnings = TRUE, recursive = TRUE)
#metadata_path <- file.path(data_path, "metadata_remove_unpaired_low_align.csv")
#dir.create(webgestalt_path, recursive=TRUE)
metadata_path <- file.path(data_path, "all_metadata_remove_unpaired_low_align.csv") 
```


```{r count, include=FALSE}
coldata <- read.csv(file.path(metadata_path), row.names = 1) #Metadata
coldata$sample <- rownames(coldata)  # new variable:sample = rownames in 'coldata'
#coldata <- coldata[ , c("sample", "treatment", "age_group")]

count <- read.table(file.path(resPath, "rsem_counts","expected_counts.txt"), 
                    row.names = 1, header = TRUE,check.names = FALSE)
count[, 1:ncol(count)] <- sapply(count[, 1:ncol(count)], as.numeric) #convert it to numeric factors
CountData <- count[ ,rownames(coldata)]

all(colnames(CountData) %in% rownames(coldata)) # checking to see if sample names match between the two files
all(colnames(CountData) == rownames(coldata)) # checking to see if the sample names are in the same order in both files

```

## Sample Metadata

```{r metadata, echo=FALSE}
sampleInfo <- coldata
numSamples <- dim(sampleInfo)[1]
sampleInfo$Sequence <- seq_len(nrow(sampleInfo))
rownames(sampleInfo) <- NULL
knitr::kable(sampleInfo)
```



```{r lasso1}
coldata$treatment <- ifelse(coldata$treatment == "Pre", 0, 1)
coldata$treatment <- factor(coldata$treatment)
coldata$age_group <- factor(coldata$age_group)

#DESeqDataSet
dds <- DESeqDataSetFromMatrix(countData = round(CountData), colData = coldata, design = ~ treatment + age_group)

# Filter low-count genes
# perform pre-filtering to keep only rows that have at least 10 reads total and 3 replicates
dds_raw <- filter_genes(dds, min_count = 10, min_rep = 3)
dds_raw <- estimateSizeFactors(dds_raw)
idx <- rowSums(counts(dds_raw, normalized=TRUE) >= 10) >= 3
dds_raw <- dds_raw[idx,]

# Function to perform Lasso regression for each patient
lasso_per_patient <- function(patient_id, dds_raw) {
  # Subset the data for the current patient
  dds_patient <- subset(dds_raw, patient_id == patient_id)
  
  # Extract gene expression data
  x <- as.matrix(counts(dds_patient, normalized=TRUE))
  
  # Extract treatment information
  y <- as.numeric(dds_patient$treatment == "Post")
  
  # Scale the gene expression data
  x_scaled <- scale(x)
  
  # Fit Lasso model
  lasso_model <- cv.glmnet(x_scaled, y, alpha = 1)  # alpha = 1 for Lasso
  
  # Return the Lasso model
  return(lasso_model)
}

# Get unique patient IDs
unique_patient_ids <- unique(colData(dds_raw)$patient_id)

# Initialize a list to store Lasso models for each patient
lasso_models <- lapply(patient_ids, lasso_per_patient, dds_raw)

# Access the coefficients or other information for a specific patient
# Example: Coefficients for the first patient
coefficients_first_patient <- coef(lasso_models[[1]])

# Perform 10-fold cross-validation and identify best predictors
idealLambdas <- sapply(lasso_models, function(lasso_model) {
  cv_model <- cv.glmnet(x = as.matrix(counts(dds_raw, normalized=TRUE)),
                        y = as.numeric(dds_raw$treatment == "Post"),
                        alpha = 1,
                        nfolds = 10,
                        family = "binomial")
  return(c(lambda.min = cv_model$lambda.min, lambda.1se = cv_model$lambda.1se))
})

# Identify predictors for each patient
predictors_per_patient <- lapply(seq_along(patient_ids), function(i) {
  predict_nonzero <- predict(lasso_models[[i]], type = "nonzero", s = idealLambdas[, i, drop = FALSE]$lambda.1se)
  predict_nonzero_matrix <- counts(dds_raw, normalized = TRUE)[, predict_nonzero$s1]
  genes_glm_ready <- colnames(predict_nonzero_matrix)
  return(genes_glm_ready)
})

# Display the identified genes for each patient
for (i in seq_along(patient_ids)) {
  cat("Patient:", patient_ids[i], "\n")
  cat("Selected Genes:", predictors_per_patient[[i]], "\n\n")
}

```

```{r lasso2}
coldata$treatment <- ifelse(coldata$treatment == "Pre", 0, 1)
coldata$treatment <- factor(coldata$treatment)
coldata$age_group <- factor(coldata$age_group)

#DESeqDataSet
dds <- DESeqDataSetFromMatrix(countData = round(CountData), colData = coldata, design = ~ treatment + age_group)

# Filter low-count genes
# perform pre-filtering to keep only rows that have at least 10 reads total and 3 replicates
dds_raw <- filter_genes(dds, min_count = 10, min_rep = 3)
dds_raw <- estimateSizeFactors(dds_raw)
idx <- rowSums(counts(dds_raw, normalized=TRUE) >= 10) >= 3
dds_raw <- dds_raw[idx,]

# TPM --> z score 
# DESeq analysis
dds_Diff <- DESeq(dds_raw)
# make a transformed count matrix, using variance stabilizing transformation (VST)
# stabilize the variance across the mean, making the data more suitable for downstream analyses
vsd <- vst(dds_Diff, blind=FALSE)
vst_counts <- as.matrix(assay(vsd))
#library("vsn")
meanSdPlot(vst_counts)

mat_df <- as.data.frame(t(vst_counts))
mat_df$sample <- rownames(mat_df)
DATA_Model <- merge(mat_df, coldata, by = 'sample', all = TRUE)

# Lasso model

DATA_Model_lasso <- DATA_Model[, -which(names(DATA_Model) %in% colnames(coldata))]
# Fit Lasso model: alpha = 1 for L1 penalty
lassoModel <- glmnet(x = as.matrix(DATA_Model_lasso), y = as.factor(DATA_Model$treatment), alpha = 1, family = "binomial", standardize = TRUE)
summary(lassoModel)
# Perform 10-fold cross-validation
cv.lassoModel <- cv.glmnet(x = as.matrix(DATA_Model_lasso), y = as.factor(DATA_Model$treatment), alpha = 1, nfolds = 5, family = "binomial", parallel = TRUE)
# Identify best predictors based on cross-validation
idealLambda <- cv.lassoModel$lambda.min
idealLambda1se <- cv.lassoModel$lambda.1se


# Derive coefficients for each gene
co <- coef(cv.lassoModel, s = idealLambda, exact = TRUE)
co.se <- coef(cv.lassoModel, s = idealLambda1se, exact = TRUE)

# Identify predictors
predict_nonzero <- predict(cv.lassoModel, type = "nonzero", s = idealLambda1se)
predict_nonzero_matrix <- DATA_Model_lasso[, predict_nonzero$s1]
Genes_GLM_ready <- colnames(predict_nonzero_matrix)

# Fit logistic regression without regularization
# lassoModel_no_penalty <- glm(treatment ~ ., data = DATA_Model, family = "binomial")

# Display the summary of the model
#summary(lassoModel_no_penalty)
```

```{r lasso3}
# Create DESeqDataSet
dds <- DESeqDataSetFromMatrix(countData = round(CountData), colData = coldata, design = ~ treatment + age_group)

# Filter low-count genes
dds <- DESeqDataSet(dds, preFilter = TRUE)
dds <- estimateSizeFactors(dds)
dds <- dds[ rowSums(counts(dds, normalized=TRUE) >= 10) >= 3, ]

# DESeq analysis
dds <- DESeq(dds)
vsd_data <- vst(dds)

# Merge data
mat <- assay(vsd_data)
mat_df <- as.data.frame(t(mat))
mat_df$sample <- rownames(mat_df)
DATA_Model <- merge(mat_df, coldata, by = 'sample', all = TRUE)

# Lasso model
DATA_Model_lasso <- DATA_Model[, -which(names(DATA_Model) %in% colnames(coldata))]
lassoModel <- glmnet(x = as.matrix(DATA_Model_lasso), y = as.factor(DATA_Model$treatment), alpha = 1, family = "binomial")

# Perform 10-fold cross-validation
cv.lassoModel <- cv.glmnet(x = as.matrix(DATA_Model_lasso), y = as.factor(DATA_Model$treatment), alpha = 1, nfolds = 10, family = "binomial", parallel = TRUE)

# Identify best predictors
idealLambda1se <- cv.lassoModel$lambda.1se

# Identify predictors
predict_nonzero <- predict(cv.lassoModel, type = "nonzero", s = idealLambda1se)
predict_nonzero_matrix <- DATA_Model_lasso[, predict_nonzero$s1]
Genes_GLM_ready <- colnames(predict_nonzero_matrix)

# Fit logistic regression without regularization
lassoModel_no_penalty <- glm(treatment ~ ., data = DATA_Model, family = "binomial")

# Display the summary of the model
summary(lassoModel_no_penalty)

```

